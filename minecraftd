#!/usr/bin/env python3
import argparse
import asyncio
import logging
import os
import re
import subprocess
import sys
import tarfile
from datetime import datetime
from signal import SIG_IGN, SIGINT, SIGTERM, signal

_RE_OUTPUT_LINE = re.compile(r"^(?P<time>\[[\d\:]+\])\s*(?P<thread>\[[^\]]*\])\:\s*(?P<message>(.+))$")
_RE_OUTPUT_LOADING_DONE = re.compile(r"^Done\s\([\d\.]+s\)!.*", re.IGNORECASE)
_RE_OUTPUT_SAVING_OFF_DONE = re.compile(
    r"(Automatic saving is now disabled|Saving is already turned off)", re.IGNORECASE
)
_RE_OUTPUT_SAVING_ON_DONE = re.compile(r"(Automatic saving is now enabled|Saving is already turned on)", re.IGNORECASE)
_RE_OUTPUT_SAVING_DONE = re.compile(r"Saved the game", re.IGNORECASE)

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("minecraftd")


class Waiter:
    def __init__(self, pattern):
        self.pattern = pattern
        self._fut = asyncio.get_event_loop().create_future()

    def try_resolve(self, message):
        if self.pattern.match(message):
            self.resolve()
            return True
        return False

    def resolve(self):
        self._fut.set_result(None)

    async def wait(self):
        await self._fut


class OutputParser:
    """
    This class parses the stdout output coming from the minecraft server. It can create `Waiter` objects that can
    be used to wait for a specific line of output to be generated by the server. This allows tasks to wait for
    completion of their server command.
    """

    def __init__(self, stdout):
        self._stdout = stdout
        self._waiters = []
        asyncio.ensure_future(self._thread_cb())

    async def _thread_cb(self):
        while True:
            line = await self._stdout.readline()
            if not line:
                break

            line = line.decode().strip()
            sys.stdout.write(line)
            sys.stdout.write("\n")
            sys.stdout.flush()

            m = _RE_OUTPUT_LINE.match(line)

            self._waiters = [w for w in self._waiters if not w.try_resolve(m.group("message"))]

    def add_waiter(self, pattern):
        waiter = Waiter(pattern)
        self._waiters.append(waiter)
        return waiter


class InputFormatter:
    def __init__(self, stdin):
        self._stdin = stdin

    async def send_cmd(self, cmd):
        self._stdin.write(cmd.encode())
        self._stdin.write(b"\n")
        await self._stdin.drain()


class BaseTask:
    async def execute(self, inf: InputFormatter, op: OutputParser):
        raise NotImplementedError

    def should_shutdown(self):
        return False


class LoadTask(BaseTask):
    """
    This task waits for the server to be done loading after being started.
    """

    async def execute(self, inf: InputFormatter, op: OutputParser):
        await op.add_waiter(_RE_OUTPUT_LOADING_DONE).wait()
        logger.info("loading finished")


class StopTask(BaseTask):
    """
    This tasks tells the server to shutdown gracefully. It needs to be paired with a `wait` call
    on the minecraft process.
    """

    async def execute(self, inf: InputFormatter, op: OutputParser):
        await inf.send_cmd("stop")
        logger.info("stop sent")

    def should_shutdown(self):
        return True


class BackupTask(BaseTask):
    """
    This task performs a safe backup by turning off the auto-save mode, flushing out all the pending changes,
    creating the backup and then turning auto-save back on.
    """

    def __init__(self, backup_path, world_path):
        super().__init__()
        self._backup_path = backup_path
        self._world_path = world_path

    async def execute(self, inf: InputFormatter, op: OutputParser):
        w = op.add_waiter(_RE_OUTPUT_SAVING_OFF_DONE)
        await inf.send_cmd("save-off")
        await w.wait()

        def backup():
            logger.info("backup started")

            path = os.path.join(
                self._backup_path, "world_{}.tar.gz".format(datetime.now().strftime("%Y-%m-%d_%H:%M:%S"))
            )
            with tarfile.open(path, "w:gz") as f:
                f.add(self._world_path, "world")

            logger.info("backup finished")

        await asyncio.get_event_loop().run_in_executor(None, backup)

        w = op.add_waiter(_RE_OUTPUT_SAVING_ON_DONE)
        await inf.send_cmd("save-on")
        await w.wait()


class TaskRunner:
    """
    This class serializes the access to the minecraft process' stdin in order to avoid sending multiple commands
    to the server at once. Access to the server is represented by tasks, which send commands via stdin and wait
    for the proper output to be received via waiters.
    """

    def __init__(self, inf: InputFormatter, op: OutputParser):
        self.inf = inf
        self.op = op
        self._tasks = asyncio.Queue()
        asyncio.ensure_future(self._thread_cb())

    async def _thread_cb(self):
        while True:
            task = await self._tasks.get()
            try:
                await task.execute(self.inf, self.op)
            except Exception as e:
                logger.error("task error %s", e)
            finally:
                if task.should_shutdown():
                    break

    async def add_task(self, task: BaseTask):
        await self._tasks.put(task)


async def spawn(args, backup_interval, backup_path, world_path=None):
    if world_path is None:
        world_path = os.getcwd()

    def preexec():
        signal(SIGTERM, SIG_IGN)
        signal(SIGINT, SIG_IGN)

    p = await asyncio.create_subprocess_exec(
        *args, cwd=world_path, preexec_fn=preexec, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=None
    )

    op = OutputParser(p.stdout)
    tr = TaskRunner(InputFormatter(p.stdin), op)
    await tr.add_task(LoadTask())

    def handler():
        print()
        logger.info("shutdown requested")
        asyncio.ensure_future(tr.add_task(StopTask()))

    asyncio.get_event_loop().add_signal_handler(SIGTERM, handler)
    asyncio.get_event_loop().add_signal_handler(SIGINT, handler)

    async def timer():
        while True:
            await asyncio.sleep(backup_interval)
            await tr.add_task(BackupTask(backup_path, world_path))

    asyncio.ensure_future(timer())

    await p.wait()

    logger.info("exit code is %d", p.returncode)
    sys.exit(p.returncode)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(prog="minecraftd")
    parser.add_argument(
        "-j", "--jar-path", dest="jar_path", help="path to the minecraft server jar", default="server.jar"
    )
    parser.add_argument(
        "-i",
        "--backup-interval",
        dest="backup_interval",
        help="time between backups in seconds",
        type=int,
        default=3600,
    )
    parser.add_argument(
        "-b", "--backup-path", dest="backup_path", help="directory where backups are stored", required=True
    )
    parser.add_argument("-w", "--world-path", dest="world_path", help="directory where the world is", default=None)

    parser.add_argument("-o", dest="opts", nargs="*", default=[], help="Additional arguments to the JVM")

    args = parser.parse_args()

    args_list = ["/usr/bin/java", "-server", "-XX:MaxGCPauseMillis=100"] + args.opts + ["-jar", args.jar_path, "nogui"]
    logger.info("spawning minecraft: %s", args_list)

    asyncio.get_event_loop().run_until_complete(
        spawn(args_list, args.backup_interval, args.backup_path, args.world_path)
    )
